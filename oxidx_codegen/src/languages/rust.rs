use crate::schema::{ComponentNode, WindowSchema};
use crate::traits::CodeGenerator;
use anyhow::{Context, Result};
use serde_json::Value;

pub struct RustGenerator;

struct GenContext {
    counter: usize,
}

impl GenContext {
    fn new() -> Self {
        Self { counter: 0 }
    }

    fn next_var(&mut self, prefix: &str) -> String {
        self.counter += 1;
        // Sanitize for valid rust identifiers if needed, though prefix usually comes from component type
        format!("{}_{}", prefix.to_lowercase(), self.counter)
    }
}

impl CodeGenerator for RustGenerator {
    fn generate(&self, schema: &WindowSchema) -> Result<String> {
        let mut ctx = GenContext::new();
        let (root_var, code) = generate_node(&schema.root, &mut ctx)?;

        let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S");

        Ok(format!(
            r#"// Generated by oxidx_codegen at {timestamp}
// Schema: {name}

use oxidx_core::{{run_with_config, AppConfig, Color, OxidXComponent, OxidXContext, Rect, Vec2, Spacing}};
use oxidx_core::layout::StackAlignment;
use oxidx_std::prelude::*;

pub fn main() {{
    {code}
    run_with_config(
        {root_var},
        AppConfig::new("{name}").with_size(800, 600)
    );
}}
"#,
            timestamp = timestamp,
            name = schema.name,
            code = code.replace("\n", "\n    "),
            root_var = root_var
        ))
    }
}

fn generate_node(node: &ComponentNode, ctx: &mut GenContext) -> Result<(String, String)> {
    let mut code_block = String::new();

    // Specific Handling for SplitView
    if node.component_type == "SplitView" {
        return generate_split_view(node, ctx);
    }

    // Determine instantiation based on component type and props
    let var_name = ctx.next_var(&node.component_type);

    let instantiation =
        match node.component_type.as_str() {
            "Label" => {
                let text = node.props.get("text").and_then(|v| v.as_str()).unwrap_or(
                    if !node.id.is_empty() {
                        &node.id
                    } else {
                        "Label"
                    },
                );
                format!("let mut {} = Label::new(\"{}\");\n", var_name, text)
            }
            "Input" => {
                let ph = node
                    .props
                    .get("placeholder")
                    .and_then(|v| v.as_str())
                    .or(node.props.get("text").and_then(|v| v.as_str()))
                    .unwrap_or("");
                format!("let mut {} = Input::new(\"{}\");\n", var_name, ph)
            }
            "Button" => {
                format!("let mut {} = {}::new();\n", var_name, node.component_type)
            }
            "VStack" => format!("let mut {} = VStack::new();\n", var_name),
            "HStack" => format!("let mut {} = HStack::new();\n", var_name),
            "ZStack" => format!("let mut {} = ZStack::new();\n", var_name),
            _ => format!("let mut {} = {}::new();\n", var_name, node.component_type),
        };

    code_block.push_str(&instantiation);

    // Sort props for deterministic output
    let mut sorted_props: Vec<_> = node.props.iter().collect();
    sorted_props.sort_by_key(|(k, _)| *k);

    for (key, value) in sorted_props {
        // Skip props handled in constructor
        if (node.component_type == "Label" && key == "text")
            || (node.component_type == "Input" && (key == "placeholder" || key == "text"))
        {
            continue;
        }

        let prop_code = map_prop(&node.component_type, var_name.as_str(), key, value);
        if !prop_code.is_empty() {
            code_block.push_str(&prop_code);
            code_block.push('\n');
        }
    }

    // Handle ID if present in node struct (override props)
    if !node.id.is_empty() {
        let id = &node.id;
        if !node.props.contains_key("id")
            && !matches!(node.component_type.as_str(), "VStack" | "HStack" | "ZStack")
        {
            code_block.push_str(&format!(
                "{} = {}.with_id(\"{}\");\n",
                var_name, var_name, id
            ));
        }
    }

    // Recurse Children
    if let Some(children) = &node.children {
        for child in children {
            let (child_var, child_code) = generate_node(child, ctx)?;
            code_block.push_str(&child_code);
            code_block.push_str(&format!(
                "{}.add_child(Box::new({}));\n",
                var_name, child_var
            ));
        }
    }

    Ok((var_name, code_block))
}

fn generate_split_view(node: &ComponentNode, ctx: &mut GenContext) -> Result<(String, String)> {
    let mut code_block = String::new();

    let children = node.children.as_ref().map(|v| v.as_slice()).unwrap_or(&[]);

    if children.len() != 2 {
        let var_name = ctx.next_var("split_view_error");
        return Ok((var_name.clone(), format!("// Error: SplitView requires exactly 2 children\nlet {} = SplitView::horizontal(Label::new(\"Err\"), Label::new(\"Err\"));\n", var_name)));
    }

    // Recursively generate children FIRST
    let (child1_var, child1_code) = generate_node(&children[0], ctx)?;
    let (child2_var, child2_code) = generate_node(&children[1], ctx)?;

    code_block.push_str(&child1_code);
    code_block.push_str(&child2_code);

    let var_name = ctx.next_var("split_view");

    // Determine orientation
    let orientation = node
        .props
        .get("orientation")
        .and_then(|v| v.as_str())
        .unwrap_or("Horizontal");

    let constructor = if orientation == "Vertical" {
        "vertical"
    } else {
        "horizontal"
    };

    let instantiation = format!(
        "let mut {} = SplitView::{}({}, {});\n",
        var_name, constructor, child1_var, child2_var
    );

    code_block.push_str(&instantiation);

    // Props
    let mut sorted_props: Vec<_> = node.props.iter().collect();
    sorted_props.sort_by_key(|(k, _)| *k);

    for (key, value) in sorted_props {
        if key == "orientation" {
            continue;
        }
        let prop_code = map_prop("SplitView", var_name.as_str(), key, value);
        if !prop_code.is_empty() {
            code_block.push_str(&prop_code);
            code_block.push('\n');
        }
    }

    Ok((var_name, code_block))
}

fn map_prop(comp_type: &str, var_name: &str, key: &str, value: &Value) -> String {
    // Return full statement like: "var.set_prop(...);" or "var = var.with_prop(...);"

    // Handle "id": Not supported by VStack/HStack/ZStack
    if key == "id" {
        if matches!(comp_type, "VStack" | "HStack" | "ZStack") {
            return String::new();
        }
        // Others support .with_id() which is a builder returning Self
        if let Value::String(s) = value {
            return format!("{} = {}.with_id(\"{}\");", var_name, var_name, s);
        }
        return String::new();
    }

    // Handle "spacing": VStack/HStack use set_spacing (mut setter)
    if key == "spacing" {
        if let Some(n) = value.as_f64() {
            // Assuming Spacing::gap for simple float
            return format!("{}.set_spacing(Spacing::new(0.0, {:.1}));", var_name, n);
            // Note: Original code used Spacing::new(0.0, n) in rust.rs but Spacing::gap(n) in cli/codegen.rs
            // Let's prefer Spacing::new(0.0, n) or Spacing::gap(n) if available?
            // oxidx_core usually has Spacing::new(h, v).
        }
    }

    // Handle "text" for Buttons/Labels
    if key == "text" && comp_type == "Button" {
        if let Some(s) = value.as_str() {
            return format!("{} = {}.label(\"{}\");", var_name, var_name, s);
        }
    }

    if key == "text" && comp_type == "Label" {
        if let Some(s) = value.as_str() {
            return format!("{} = {}.text(\"{}\");", var_name, var_name, s);
        }
    }

    // Handle "size" for Label
    if key == "size" && comp_type == "Label" {
        if let Some(n) = value.as_f64() {
            return format!("{} = {}.with_size({:.1});", var_name, var_name, n);
        }
    }

    // Handle "alignment" for VStack/HStack
    if key == "alignment" {
        if let Some(s) = value.as_str() {
            let align_enum = match s {
                "Start" => "StackAlignment::Start",
                "Center" => "StackAlignment::Center",
                "End" => "StackAlignment::End",
                "Stretch" => "StackAlignment::Stretch",
                _ => "StackAlignment::Start",
            };
            return format!("{}.set_alignment({});", var_name, align_enum);
        }
    }

    // Handle "padding" for ZStack
    if key == "padding" && comp_type == "ZStack" {
        if let Some(n) = value.as_f64() {
            return format!("{} = {}.with_padding({:.1});", var_name, var_name, n);
        }
    }

    // Default builder pattern
    let method = match key {
        "text" => "label",
        _ => key,
    };

    format!(
        "{} = {}.{}({});",
        var_name,
        var_name,
        method,
        val_to_str(value)
    )
}

fn val_to_str(value: &Value) -> String {
    match value {
        Value::String(s) => format!("\"{}\"", s),
        Value::Bool(b) => b.to_string(),
        Value::Number(n) => n.to_string(),
        Value::Null => "None".to_string(),
        _ => format!("{:?}", value),
    }
}
