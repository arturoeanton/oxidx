use crate::schema::{ComponentNode, WindowSchema};
use crate::traits::CodeGenerator;
use anyhow::Result;
use std::fmt::Write;

pub struct RustGenerator;

impl CodeGenerator for RustGenerator {
    fn generate(&self, schema: &WindowSchema) -> Result<String> {
        let mut code = String::new();
        let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S");

        // 1. Header & Imports
        writeln!(code, "// Generated by oxidx_codegen at {}", timestamp)?;
        writeln!(code, "// Schema: {}", schema.name)?;
        writeln!(code, "")?;
        writeln!(code, "use oxidx_std::prelude::*;")?;
        writeln!(code, "use oxidx_core::{{Color, OxidXComponent, OxidXContext, Rect, Vec2, AppConfig, run_with_config}};")?;
        writeln!(code, "")?;

        // 2. Main Function wrapper
        writeln!(code, "pub fn main() {{")?;

        // 3. Recursive Generation
        let mut counter = 0;
        let root_var = generate_node(&mut code, &schema.root, &mut counter)?;

        // 4. Run Loop
        writeln!(code, "")?;
        writeln!(code, "    run_with_config(")?;
        writeln!(code, "        {},", root_var)?;
        writeln!(
            code,
            "        AppConfig::new(\"{}\").with_size(800, 600)",
            schema.name
        )?;
        writeln!(code, "    );")?;
        writeln!(code, "}}")?;

        Ok(code)
    }
}

fn generate_node(code: &mut String, node: &ComponentNode, counter: &mut usize) -> Result<String> {
    *counter += 1;
    let var_name = if !node.id.is_empty() {
        // Sanitize ID to be a valid identifier
        node.id.replace("-", "_").replace(" ", "_").to_lowercase()
    } else {
        format!("{}_{}", node.component_type.to_lowercase(), counter)
    };

    // 1. Instantiation
    match node.component_type.as_str() {
        "VStack" => {
            writeln!(code, "    let mut {} = VStack::new();", var_name)?;

            // Handle specific VStack props
            if let Some(spacing) = node.props.get("spacing") {
                if let Some(s) = spacing.as_f64() {
                    writeln!(
                        code,
                        "    {}.set_spacing(Spacing::new(0.0, {:.1}));",
                        var_name, s
                    )?;
                }
            }
            if let Some(align) = node.props.get("alignment") {
                if let Some(s) = align.as_str() {
                    let rust_align = match s {
                        "Center" => "StackAlignment::Center",
                        "End" => "StackAlignment::End",
                        "Stretch" => "StackAlignment::Stretch",
                        _ => "StackAlignment::Start",
                    };
                    writeln!(code, "    {}.set_alignment({});", var_name, rust_align)?;
                }
            }
        }
        "HStack" => {
            writeln!(code, "    let mut {} = HStack::new();", var_name)?;
            // Similar mapping...
        }
        "ZStack" => {
            writeln!(code, "    let mut {} = ZStack::new();", var_name)?;
            if let Some(padding) = node.props.get("padding") {
                if let Some(p) = padding.as_f64() {
                    writeln!(
                        code,
                        "    {} = {}.with_padding({:.1});",
                        var_name, var_name, p
                    )?;
                }
            }
        }
        "Button" => {
            // Use new derive-macro-powered fluent API
            let text = node.props.get("text").and_then(|v| v.as_str());

            let width = node
                .props
                .get("width")
                .and_then(|v| v.as_f64())
                .unwrap_or(100.0);
            let height = node
                .props
                .get("height")
                .and_then(|v| v.as_f64())
                .unwrap_or(40.0);

            writeln!(code, "    let {} = Button::new()", var_name)?;
            writeln!(
                code,
                "        .preferred_size(Vec2::new({:.1}, {:.1}))",
                width, height
            )?;
            if let Some(label) = text {
                writeln!(code, "        .label(\"{}\")", label)?;
            }
            writeln!(code, "        ;")?;
        }
        "Input" => {
            let placeholder = node
                .props
                .get("placeholder")
                .and_then(|v| v.as_str())
                .unwrap_or("Text Input");
            writeln!(
                code,
                "    let mut {} = Input::new(\"{}\");",
                var_name, placeholder
            )?;

            if !node.id.is_empty() {
                writeln!(
                    code,
                    "    {} = {}.with_id(\"{}\");",
                    var_name, var_name, node.id
                )?;
            }
        }
        "Label" => {
            let text = node
                .props
                .get("text")
                .and_then(|v| v.as_str())
                .unwrap_or("Label");
            writeln!(code, "    let mut {} = Label::new(\"{}\");", var_name, text)?;

            if let Some(size) = node.props.get("size") {
                if let Some(s) = size.as_f64() {
                    writeln!(code, "    {} = {}.with_size({:.1});", var_name, var_name, s)?;
                }
            }
        }
        "Container" => {
            // Generic container, maybe just a ZStack or similar?
            // Or a specialized Container component?
            // Using ZStack for generic container behavior as per demo
            writeln!(code, "    let mut {} = ZStack::new();", var_name)?;
        }
        _ => {
            writeln!(
                code,
                "    // Unknown component type: {}",
                node.component_type
            )?;
            writeln!(code, "    let mut {} = ZStack::new();", var_name)?;
        }
    }

    // 2. Generic Props (Style, Layout)
    if let Some(style) = &node.style {
        if let Some(bg) = style.get("bg") {
            // Handle hex color parsing
            writeln!(
                code,
                "    {}.set_background(Color::from_hex(\"{}\").unwrap_or(Color::BLACK));",
                var_name, bg
            )?;
        }
    }

    // 3. Children Recursion
    if let Some(children) = &node.children {
        for child in children {
            let child_var = generate_node(code, child, counter)?;
            writeln!(code, "    {}.add_child(Box::new({}));", var_name, child_var)?;
        }
    }

    Ok(var_name)
}
