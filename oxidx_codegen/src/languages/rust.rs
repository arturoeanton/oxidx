use crate::schema::{ComponentNode, WindowSchema};
use crate::traits::CodeGenerator;
use anyhow::Result;
use serde_json::Value;

pub struct RustGenerator;

struct GenContext {
    counter: usize,
}

impl GenContext {
    fn new() -> Self {
        Self { counter: 0 }
    }

    fn next_var(&mut self, prefix: &str) -> String {
        self.counter += 1;
        // Sanitize for valid rust identifiers if needed, though prefix usually comes from component type
        format!("{}_{}", prefix.to_lowercase(), self.counter)
    }
}

impl CodeGenerator for RustGenerator {
    fn generate(&self, schema: &WindowSchema) -> Result<String> {
        let mut ctx = GenContext::new();
        let (root_var, code) = generate_node(&schema.root, &mut ctx)?;

        let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S");

        Ok(format!(
            r#"// Generated by oxidx_codegen at {timestamp}
// Schema: {name}

use oxidx_core::{{run_with_config, AppConfig, Color, OxidXComponent, OxidXContext, Rect, Vec2, Spacing}};
use oxidx_core::layout::StackAlignment;
use oxidx_std::prelude::*;

pub fn main() {{
    {code}
    run_with_config(
        {root_var},
        AppConfig::new("{name}").with_size(800, 600)
    );
}}
"#,
            timestamp = timestamp,
            name = schema.name,
            code = code.replace("\n", "\n    "),
            root_var = root_var
        ))
    }
}

fn generate_node(node: &ComponentNode, ctx: &mut GenContext) -> Result<(String, String)> {
    let mut code_block = String::new();

    // Specific Handling for SplitView
    if node.component_type == "SplitView" {
        return generate_split_view(node, ctx);
    }

    // Determine instantiation based on component type and props
    let var_name = ctx.next_var(&node.component_type);

    let instantiation =
        match node.component_type.as_str() {
            "Label" => {
                let text = node.props.get("text").and_then(|v| v.as_str()).unwrap_or(
                    if !node.id.is_empty() {
                        &node.id
                    } else {
                        "Label"
                    },
                );
                format!("let mut {} = Label::new(\"{}\");\n", var_name, text)
            }
            "Input" => {
                let ph = node
                    .props
                    .get("placeholder")
                    .and_then(|v| v.as_str())
                    .or(node.props.get("text").and_then(|v| v.as_str()))
                    .unwrap_or("");
                format!("let mut {} = Input::new(\"{}\");\n", var_name, ph)
            }
            "Button" => {
                format!("let mut {} = {}::new();\n", var_name, node.component_type)
            }
            "ListBox" => {
                let id = if !node.id.is_empty() {
                    node.id.as_str()
                } else {
                    node.props
                        .get("id")
                        .and_then(|v| v.as_str())
                        .unwrap_or("listbox")
                };
                format!("let mut {} = ListBox::new(\"{}\");\n", var_name, id)
            }
            "ComboBox" => {
                let id = if !node.id.is_empty() {
                    node.id.as_str()
                } else {
                    node.props
                        .get("id")
                        .and_then(|v| v.as_str())
                        .unwrap_or("combobox")
                };
                format!("let mut {} = ComboBox::new(\"{}\");\n", var_name, id)
            }
            "ProgressBar" | "Progress" => {
                format!("let mut {} = ProgressBar::default();\n", var_name)
            }
            "RadioGroup" => {
                let id = if !node.id.is_empty() {
                    node.id.as_str()
                } else {
                    node.props
                        .get("id")
                        .and_then(|v| v.as_str())
                        .unwrap_or("radiogroup")
                };

                let options_code = if let Some(Value::Array(arr)) = node.props.get("options") {
                    let items: Vec<String> = arr
                        .iter()
                        .filter_map(|v| v.as_str().map(|s| s.to_string()))
                        .collect();
                    let code = items
                        .iter()
                        .map(|s| format!("\"{}\".to_string()", s))
                        .collect::<Vec<_>>()
                        .join(", ");
                    format!("vec![{}]", code)
                } else {
                    "Vec::new()".to_string()
                };

                format!(
                    "let mut {} = RadioGroup::new(\"{}\", {});\n",
                    var_name, id, options_code
                )
            }
            "VStack" => format!("let mut {} = VStack::new();\n", var_name),
            "HStack" => format!("let mut {} = HStack::new();\n", var_name),
            "ZStack" => format!("let mut {} = ZStack::new();\n", var_name),
            "Grid" => {
                let id = if !node.id.is_empty() {
                    node.id.as_str()
                } else {
                    node.props
                        .get("id")
                        .and_then(|v| v.as_str())
                        .unwrap_or("grid")
                };
                format!("let mut {} = Grid::new(\"{}\");\n", var_name, id)
            }
            _ => format!("let mut {} = {}::new();\n", var_name, node.component_type),
        };

    code_block.push_str(&instantiation);

    // Sort props for deterministic output
    let mut sorted_props: Vec<_> = node.props.iter().collect();
    sorted_props.sort_by_key(|(k, _)| *k);

    // Handle Geometry First (x, y, width, height)
    let mut x = 0.0;
    let mut y = 0.0;
    let mut w = 0.0;
    let mut h = 0.0;
    let mut has_pos = false;
    let mut has_size = false;

    if let Some(v) = node.props.get("x").and_then(|v| v.as_f64()) {
        x = v;
        has_pos = true;
    }
    if let Some(v) = node.props.get("y").and_then(|v| v.as_f64()) {
        y = v;
        has_pos = true;
    }
    if let Some(v) = node.props.get("width").and_then(|v| v.as_f64()) {
        w = v;
        has_size = true;
    }
    if let Some(v) = node.props.get("height").and_then(|v| v.as_f64()) {
        h = v;
        has_size = true;
    }

    if has_pos {
        code_block.push_str(&format!("{}.set_position({:.1}, {:.1});\n", var_name, x, y));
    }
    if has_size {
        code_block.push_str(&format!("{}.set_size({:.1}, {:.1});\n", var_name, w, h));
    }

    for (key, value) in sorted_props {
        // Skip geometry, internal props, and constructor handled props
        if key == "x" || key == "y" || key == "width" || key == "height"
           || key == "offset_x" || key == "offset_y" 
           || key == "align_h" || key == "align_v"
           || key == "width_percent" || key == "height_percent"
           || key == "value" // Often internal for input
           || key == "syntax"
        // CodeEditor internal
        {
            continue;
        }

        // Explicitly filter props that shouldn't be mapped
        let skip = match (node.component_type.as_str(), key.as_str()) {
            ("Label", "text") => true,
            ("Input", "placeholder" | "text") => true,
            ("ListBox", "id" | "text" | "label") => true,
            ("ComboBox", "id" | "text" | "label") => true,
            ("RadioGroup", "id" | "text" | "label" | "options") => true,
            ("Grid", "titles" | "rows" | "columns") => true, // We handle these manually
            _ => false,
        };

        if skip {
            continue;
        }

        let mut comp_type_fixed = node.component_type.as_str();
        if comp_type_fixed == "Progress" {
            comp_type_fixed = "ProgressBar";
        }

        let prop_code = map_prop(comp_type_fixed, var_name.as_str(), key, value);
        if !prop_code.is_empty() {
            code_block.push_str(&prop_code);
            code_block.push('\n');
        }
    }

    // Handle ID if present in node struct (override props)
    if !node.id.is_empty() {
        let id = &node.id;
        if !node.props.contains_key("id")
            && !matches!(node.component_type.as_str(), "VStack" | "HStack" | "ZStack")
        {
            code_block.push_str(&format!(
                "{} = {}.with_id(\"{}\");\n",
                var_name, var_name, id
            ));
        }
    }

    // Grid specific generation for titles -> columns and rows
    if node.component_type == "Grid" {
        // Handle Columns & Titles
        let titles: Vec<String> = node
            .props
            .get("titles")
            .and_then(|v| v.as_str())
            .map(|s| s.split(',').map(|t| t.trim().to_string()).collect())
            .unwrap_or_default();

        // Columns count override
        let col_count = node
            .props
            .get("columns")
            .and_then(|v| v.as_u64())
            .map(|v| v as usize)
            .unwrap_or(titles.len().max(3)); // Default 3 if no info

        for i in 0..col_count {
            let title = if let Some(t) = titles.get(i) {
                t.to_string()
            } else {
                format!("Column {}", i + 1)
            };

            // Generate columns: grid.add_column(Column::new("col_i", "Title").width(100.0));
            code_block.push_str(&format!(
                "{}.add_column(Column::new(\"col_{}\", \"{}\").width(100.0));\n",
                var_name, i, title
            ));
        }

        // Handle Rows prop for dummy data
        if let Some(rows) = node.props.get("rows").and_then(|v| v.as_u64()) {
            for i in 0..rows {
                let mut row_code = format!("Row::new(\"row_{}\")", i);
                for c in 0..col_count {
                    row_code.push_str(&format!(".cell(\"col_{}\", \"Cell {}-{}\")", c, i, c));
                }
                code_block.push_str(&format!("{}.add_row({});\n", var_name, row_code));
            }
        }
    }

    // Recurse Children
    if let Some(children) = &node.children {
        for child in children {
            let (child_var, child_code) = generate_node(child, ctx)?;
            code_block.push_str(&child_code);
            code_block.push_str(&format!(
                "{}.add_child(Box::new({}));\n",
                var_name, child_var
            ));
        }
    }

    Ok((var_name, code_block))
}

fn generate_split_view(node: &ComponentNode, ctx: &mut GenContext) -> Result<(String, String)> {
    let mut code_block = String::new();

    let children = node.children.as_ref().map(|v| v.as_slice()).unwrap_or(&[]);

    if children.len() != 2 {
        let var_name = ctx.next_var("split_view_error");
        return Ok((var_name.clone(), format!("// Error: SplitView requires exactly 2 children\nlet {} = SplitView::horizontal(Label::new(\"Err\"), Label::new(\"Err\"));\n", var_name)));
    }

    // Recursively generate children FIRST
    let (child1_var, child1_code) = generate_node(&children[0], ctx)?;
    let (child2_var, child2_code) = generate_node(&children[1], ctx)?;

    code_block.push_str(&child1_code);
    code_block.push_str(&child2_code);

    let var_name = ctx.next_var("split_view");

    // Determine orientation
    let orientation = node
        .props
        .get("orientation")
        .and_then(|v| v.as_str())
        .unwrap_or("Horizontal");

    let constructor = if orientation == "Vertical" {
        "vertical"
    } else {
        "horizontal"
    };

    let instantiation = format!(
        "let mut {} = SplitView::{}({}, {});\n",
        var_name, constructor, child1_var, child2_var
    );

    code_block.push_str(&instantiation);

    // Props
    let mut sorted_props: Vec<_> = node.props.iter().collect();
    sorted_props.sort_by_key(|(k, _)| *k);

    for (key, value) in sorted_props {
        if key == "orientation" {
            continue;
        }
        let prop_code = map_prop("SplitView", var_name.as_str(), key, value);
        if !prop_code.is_empty() {
            code_block.push_str(&prop_code);
            code_block.push('\n');
        }
    }

    Ok((var_name, code_block))
}

fn map_prop(comp_type: &str, var_name: &str, key: &str, value: &Value) -> String {
    // Return full statement like: "var.set_prop(...);" or "var = var.with_prop(...);"

    // Handle "id": Not supported by VStack/HStack/ZStack
    if key == "id" {
        if matches!(comp_type, "VStack" | "HStack" | "ZStack") {
            return String::new();
        }
        // Others support .with_id() which is a builder returning Self
        if let Value::String(s) = value {
            return format!("{} = {}.with_id(\"{}\");", var_name, var_name, s);
        }
        return String::new();
    }

    // Handle "spacing": VStack/HStack use set_spacing (mut setter)
    if key == "spacing" {
        if let Some(n) = value.as_f64() {
            // Assuming Spacing::gap for simple float
            return format!("{}.set_spacing(Spacing::new(0.0, {:.1}));", var_name, n);
            // Note: Original code used Spacing::new(0.0, n) in rust.rs but Spacing::gap(n) in cli/codegen.rs
            // Let's prefer Spacing::new(0.0, n) or Spacing::gap(n) if available?
            // oxidx_core usually has Spacing::new(h, v).
        }
    }

    // Handle "text" for Buttons/Labels
    if key == "text" && comp_type == "Button" {
        if let Some(s) = value.as_str() {
            return format!("{} = {}.label(\"{}\");", var_name, var_name, s);
        }
    }

    if key == "text" && comp_type == "Label" {
        if let Some(s) = value.as_str() {
            return format!("{} = {}.text(\"{}\");", var_name, var_name, s);
        }
    }

    // Handle "size" for Label
    if key == "size" && comp_type == "Label" {
        if let Some(n) = value.as_f64() {
            return format!("{} = {}.with_size({:.1});", var_name, var_name, n);
        }
    }

    // Handle "alignment" for VStack/HStack
    if key == "alignment" {
        if let Some(s) = value.as_str() {
            let align_enum = match s {
                "Start" => "StackAlignment::Start",
                "Center" => "StackAlignment::Center",
                "End" => "StackAlignment::End",
                "Stretch" => "StackAlignment::Stretch",
                _ => "StackAlignment::Start",
            };
            return format!("{}.set_alignment({});", var_name, align_enum);
        }
    }

    // Handle "padding" for ZStack
    if key == "padding" && comp_type == "ZStack" {
        if let Some(n) = value.as_f64() {
            return format!("{} = {}.with_padding({:.1});", var_name, var_name, n);
        }
    }

    // Handle "options" for ListBox (JSON array -> Vec<String>)
    if key == "options" && comp_type == "ListBox" {
        if let Value::Array(arr) = value {
            let items: Vec<String> = arr
                .iter()
                .filter_map(|v| v.as_str().map(|s| s.to_string()))
                .collect();
            // Generate vec!["a".to_string(), "b".to_string()]
            let items_code = items
                .iter()
                .map(|s| format!("\"{}\".to_string()", s))
                .collect::<Vec<_>>()
                .join(", ");
            return format!("{} = {}.items(vec![{}]);", var_name, var_name, items_code);
        }
    }

    // ComboBox: Handle options -> items
    if key == "options" && comp_type == "ComboBox" {
        if let Value::Array(arr) = value {
            let items: Vec<String> = arr
                .iter()
                .filter_map(|v| v.as_str().map(|s| s.to_string()))
                .collect();
            let items_code = items
                .iter()
                .map(|s| format!("\"{}\".to_string()", s))
                .collect::<Vec<_>>()
                .join(", ");
            return format!("{} = {}.items(vec![{}]);", var_name, var_name, items_code);
        }
    }

    // ListBox: Explicitly skip text/id/label again to be safe
    if comp_type == "ListBox" && (key == "text" || key == "id" || key == "label") {
        return String::new();
    }

    // Default builder pattern
    let method = match key {
        "text" if comp_type == "Button" || comp_type == "Label" => "label",
        _ => key,
    };

    format!(
        "{} = {}.{}({});",
        var_name,
        var_name,
        method,
        val_to_str(value)
    )
}

fn val_to_str(value: &Value) -> String {
    match value {
        Value::String(s) => format!("\"{}\"", s),
        Value::Bool(b) => b.to_string(),
        Value::Number(n) => n.to_string(),
        Value::Null => "None".to_string(),
        Value::Array(arr) => {
            // Basic array handling - mapped to vec
            let items: Vec<String> = arr.iter().map(|v| val_to_str(v)).collect();
            format!("vec![{}]", items.join(", "))
        }
        _ => format!("{:?}", value),
    }
}
