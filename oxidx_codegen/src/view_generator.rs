//! # View Generator
//!
//! Generates Rust source code from `oxidx_core::schema::ComponentNode`.
//!
//! This module provides the `generate_view()` function that transforms
//! a UI schema into a compilable Rust struct with constructor.

use heck::{ToSnakeCase, ToUpperCamelCase};
use oxidx_core::schema::ComponentNode;
use std::collections::HashSet;

/// Code generation context tracking state during recursive walking.
struct GenContext {
    /// Counter for auto-generating variable names
    counter: usize,
    /// Struct field definitions (e.g., "pub btn_login: Button")
    struct_fields: Vec<String>,
    /// Initialization lines in new() (e.g., "let btn_login = Button::new()...")
    init_lines: Vec<String>,
    /// Tree assembly lines (e.g., "root.add_child(Box::new(btn_login))")
    tree_assembly: Vec<String>,
    /// Required imports
    imports: HashSet<String>,
}

impl GenContext {
    fn new() -> Self {
        Self {
            counter: 0,
            struct_fields: Vec::new(),
            init_lines: Vec::new(),
            tree_assembly: Vec::new(),
            imports: HashSet::new(),
        }
    }

    /// Generate a unique variable name from ID or auto-increment
    fn var_name(&mut self, node: &ComponentNode) -> String {
        if let Some(ref id) = node.id {
            if !id.is_empty() {
                return id.to_snake_case();
            }
        }
        self.counter += 1;
        format!("{}_{}", node.type_name.to_snake_case(), self.counter)
    }
}

/// Generates a Rust view struct from a ComponentNode schema.
///
/// # Arguments
/// * `root` - The root of the component tree
/// * `view_name` - Name for the generated struct (e.g., "LoginView")
///
/// # Example
/// ```ignore
/// let json = r#"{"type_name": "VStack", "children": [...]}"#;
/// let node: ComponentNode = serde_json::from_str(json)?;
/// let code = generate_view(&node, "MyLoginView");
/// println!("{}", code);
/// ```
pub fn generate_view(root: &ComponentNode, view_name: &str) -> String {
    let mut ctx = GenContext::new();

    // Generate the root component
    let root_var = generate_node(root, &mut ctx, None);

    // Build imports
    let mut imports_vec: Vec<_> = ctx.imports.iter().cloned().collect();
    imports_vec.sort();
    let imports_str = imports_vec.join(", ");

    // Build struct fields (with trailing commas)
    let fields_str = if ctx.struct_fields.is_empty() {
        String::new()
    } else {
        ctx.struct_fields
            .iter()
            .map(|f| format!("{},", f))
            .collect::<Vec<_>>()
            .join("\n    ")
    };

    // Build init lines
    let init_str = ctx.init_lines.join("\n        ");

    // Build tree assembly
    let assembly_str = ctx.tree_assembly.join("\n        ");

    // Generate the output code
    let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S");
    let struct_name = view_name.to_upper_camel_case();

    format!(
        r#"// Generated by oxidx_codegen at {timestamp}
// View: {struct_name}

use oxidx_core::{{OxidXComponent, OxidXContext, Rect, Vec2, Renderer, Spacing}};
use oxidx_core::layout::StackAlignment;
use oxidx_core::events::OxidXEvent;
use oxidx_std::{{{imports_str}}};

/// Generated view struct
pub struct {struct_name} {{
    {fields_str}
    root: {root_type},
}}

impl {struct_name} {{
    /// Creates a new instance of the view
    pub fn new() -> Self {{
        {init_str}

        {assembly_str}

        Self {{
            {field_init}
            root: {root_var},
        }}
    }}

    /// Returns a reference to the root component
    pub fn root(&self) -> &{root_type} {{
        &self.root
    }}

    /// Returns a mutable reference to the root component  
    pub fn root_mut(&mut self) -> &mut {root_type} {{
        &mut self.root
    }}
}}

impl OxidXComponent for {struct_name} {{
    fn update(&mut self, delta_time: f32) {{
        self.root.update(delta_time);
    }}

    fn layout(&mut self, available: Rect) -> Vec2 {{
        self.root.layout(available)
    }}

    fn render(&self, renderer: &mut Renderer) {{
        self.root.render(renderer);
    }}

    fn on_event(&mut self, event: &OxidXEvent, ctx: &mut OxidXContext) -> bool {{
        self.root.on_event(event, ctx)
    }}

    fn on_keyboard_input(&mut self, event: &OxidXEvent, ctx: &mut OxidXContext) {{
        self.root.on_keyboard_input(event, ctx);
    }}

    fn bounds(&self) -> Rect {{
        self.root.bounds()
    }}

    fn set_position(&mut self, x: f32, y: f32) {{
        self.root.set_position(x, y);
    }}

    fn set_size(&mut self, width: f32, height: f32) {{
        self.root.set_size(width, height);
    }}
}}
"#,
        timestamp = timestamp,
        struct_name = struct_name,
        imports_str = imports_str,
        fields_str = fields_str,
        root_type = root.type_name,
        init_str = init_str,
        assembly_str = assembly_str,
        field_init = ctx
            .struct_fields
            .iter()
            .filter_map(|f| {
                let parts: Vec<_> = f.split(':').collect();
                if parts.len() >= 1 {
                    let field_name = parts[0].trim().replace("pub ", "");
                    Some(format!("{},", field_name))
                } else {
                    None
                }
            })
            .collect::<Vec<_>>()
            .join("\n            "),
        root_var = root_var,
    )
}

/// Recursively generates code for a component node
fn generate_node(node: &ComponentNode, ctx: &mut GenContext, parent_var: Option<&str>) -> String {
    let var_name = ctx.var_name(node);
    let type_name = &node.type_name;

    // Add import
    ctx.imports.insert(type_name.clone());

    // Generate constructor
    let constructor = generate_constructor(node, &var_name);
    ctx.init_lines.push(constructor);

    // Generate property setters
    generate_props(node, &var_name, ctx);

    // Add struct field if component has an ID
    if node.id.is_some() && !node.id.as_ref().unwrap().is_empty() {
        ctx.struct_fields
            .push(format!("pub {}: {}", var_name, type_name));
    }

    // Handle children recursively
    for child in &node.children {
        let child_var = generate_node(child, ctx, Some(&var_name));
        ctx.tree_assembly
            .push(format!("{}.add_child(Box::new({}));", var_name, child_var));
    }

    // If there's a parent, the parent will add us as a child
    // Return our variable name
    var_name
}

/// Generate the constructor call for a component
fn generate_constructor(node: &ComponentNode, var_name: &str) -> String {
    let type_name = &node.type_name;

    match type_name.as_str() {
        "Label" => {
            let text = node
                .props
                .get("text")
                .and_then(|v| v.as_str())
                .unwrap_or("Label");
            format!("let mut {} = Label::new(\"{}\");", var_name, text)
        }
        "Input" => {
            let placeholder = node
                .props
                .get("placeholder")
                .and_then(|v| v.as_str())
                .unwrap_or("");
            format!("let mut {} = Input::new(\"{}\");", var_name, placeholder)
        }
        "Button" => {
            let mut code = format!("let mut {} = Button::new()", var_name);
            if let Some(label) = node.props.get("label").and_then(|v| v.as_str()) {
                code.push_str(&format!(".label(\"{}\")", label));
            }
            code.push(';');
            code
        }
        "VStack" | "HStack" | "ZStack" => {
            format!("let mut {} = {}::new();", var_name, type_name)
        }
        _ => {
            format!("let mut {} = {}::new();", var_name, type_name)
        }
    }
}

/// Generate property setter calls
fn generate_props(node: &ComponentNode, var_name: &str, ctx: &mut GenContext) {
    let type_name = &node.type_name;

    for (key, value) in &node.props {
        // Skip props handled in constructor
        if (type_name == "Label" && key == "text")
            || (type_name == "Input" && key == "placeholder")
            || (type_name == "Button" && key == "label")
        {
            continue;
        }

        let prop_line = match key.as_str() {
            "id" => {
                if let Some(id) = value.as_str() {
                    if !matches!(type_name.as_str(), "VStack" | "HStack" | "ZStack") {
                        Some(format!("{} = {}.with_id(\"{}\");", var_name, var_name, id))
                    } else {
                        None
                    }
                } else {
                    None
                }
            }
            "spacing" => {
                if let Some(n) = value.as_f64() {
                    Some(format!(
                        "{}.set_spacing(Spacing {{ gap: {:.1}, padding: 0.0 }});",
                        var_name, n
                    ))
                } else {
                    None
                }
            }
            "padding" => {
                if let Some(n) = value.as_f64() {
                    if type_name == "ZStack" {
                        Some(format!(
                            "{} = {}.with_padding({:.1});",
                            var_name, var_name, n
                        ))
                    } else {
                        None
                    }
                } else {
                    None
                }
            }
            "alignment" => {
                if let Some(s) = value.as_str() {
                    let align = match s {
                        "Start" => "StackAlignment::Start",
                        "Center" => "StackAlignment::Center",
                        "End" => "StackAlignment::End",
                        "Stretch" => "StackAlignment::Stretch",
                        _ => "StackAlignment::Start",
                    };
                    Some(format!("{}.set_alignment({});", var_name, align))
                } else {
                    None
                }
            }
            "password_mode" => {
                if let Some(true) = value.as_bool() {
                    Some(format!("{} = {}.password_mode(true);", var_name, var_name))
                } else {
                    None
                }
            }
            "variant" => {
                if let Some(v) = value.as_str() {
                    Some(format!(
                        "{} = {}.variant(ButtonVariant::{});",
                        var_name, var_name, v
                    ))
                } else {
                    None
                }
            }
            "disabled" => {
                // Skip false values
                if let Some(true) = value.as_bool() {
                    Some(format!("{} = {}.disabled(true);", var_name, var_name))
                } else {
                    None
                }
            }
            _ => None, // Unknown props are skipped
        };

        if let Some(line) = prop_line {
            ctx.init_lines.push(line);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_simple_button() {
        let node = ComponentNode::new("Button")
            .with_id("btn_test")
            .with_prop("label", "Click Me");

        let code = generate_view(&node, "TestView");
        assert!(code.contains("pub struct TestView"));
        assert!(code.contains("Button::new()"));
        assert!(code.contains("btn_test"));
    }

    #[test]
    fn test_generate_vstack_with_children() {
        let node = ComponentNode::new("VStack")
            .with_prop("spacing", 16.0)
            .with_child(ComponentNode::new("Label").with_prop("text", "Hello"))
            .with_child(
                ComponentNode::new("Button")
                    .with_id("btn_ok")
                    .with_prop("label", "OK"),
            );

        let code = generate_view(&node, "MyForm");
        assert!(code.contains("pub struct MyForm"));
        assert!(code.contains("VStack::new()"));
        assert!(code.contains("Label::new(\"Hello\")"));
        assert!(code.contains("add_child"));
    }
}
